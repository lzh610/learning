# SQL学习笔记  #

## 一. 关系模型 ##

#### 1. 基本数据库模型类型  ####

* 层次模型(树)
* 网状模型
* **关系模型(二维表格)** 最为常用

#### 2. 基本概念  ####

* 记录(Record)
    - 表的每一行，是一个逻辑意义上的数据
* 字段(Column)
    - 表的每一列，同一个表的每一行记录都拥有相同的若干字段
    - 定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为NULL
* 表格之间的关系
    - 一对多
    - 多对一
    - 一对一：一个表的记录对应到另一个表的唯一一个记录，用于简化表格复杂度

#### 3. 关系模型实现方式  ####

在关系数据库中，关系是通过主键和外键来维护的

##### 主键 #####

* 定义：唯一确定一条记录的字段

* 选取原则：不使用任何业务相关的字段作为主键

* 常用主键：id
    * 常用类型：
        - 自增整数类型
        - 全局唯一GUID类型

* 联合主键：允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键
    - 允许一列有重复，只要不是所有主键列都重复即可
    - 无要求时尽量不使用

##### 外键 #####

* 定义：把数据与另一张表关联起来的列

* 实现方式：定义外键约束

* 定义外键约束，关系数据库可以保证无法插入无效的数据，会降低数据库的性能，通常不设置，仅依靠应用程序的逻辑来保证

    ```
    建立外键约束
    ALTER TABLE 表2
    ADD CONSTRAINT fk_class_id
    FOREIGN KEY (外键名)
    REFERENCES 关联表 (关联列名)
    删除外键约束
    ALTER TABLE students
    DROP FOREIGN KEY fk_class_id;
    ```

* 多对多关系实现方式：通过两个一对多关系实现，即建立中间表，关联两个一对多关系

##### 索引 #####

* 定义：关系数据库中对某一列或多个列的值进行预排序的数据结构，可以加快查询速度
* 创建方式：`ADD INDEX 索引名 (索引目标列名);`
* 对于主键，关系数据库会自动对其创建主键索引
* 索引有无对数据库的构建没有影响，只是用于加快效率，因此索引可以在使用数据库的过程中逐步优化
* 唯一索引：用于约束不能作为主键，但取值唯一且各不相同的列，保证某一列的值具有唯一性
    - 定义方式：`ADD UNIQUE INDEX 唯一索引名 (索引目标列名)`


## 二. SQL语言 ##

* 结构化查询语言的缩写
* 关键字不区分大小写
* 人为规定：SQL关键字总是大写，以示突出，表名和列名均使用小写
* 以`;`作为语句的结束
* 记录集的索引从0开始
* 变量名
    字符串用单引号括起来
    
####  1. 创建表  ####

* 创建表格
    - `CREATE TABLE statistics(字段，主键...);`
* 设定字段
    - `列名 类型 NOT NULL (AUTO_INCREMENT)`
    - `AUTO_INCREMENT` 表示自增，适用于主键
* 指定主键
    - `PRIMARY KEY (列名)`

####  2. 查询语句  ####

* 基本查询 
    - `SELECT * FROM <表名>`
    - 查询一个表的所有行和所有列的数据
    - 不带FROM子句的SELECT语句用来判断当前到数据库的连接是否有效
    - 执行`SELECT 1;`来测试数据库连接

* 条件查询 
    - `SELECT * FROM <表名> WHERE <条件表达式>`
    - 筛选出符合指定条件的记录
    - 多条件表达式合并表达方式(按照优先级)
        + NOT
            * `NOT <条件>` 等价于`<>`，因此不常用
        + AND
            * `<条件1> AND <条件2>`
        + OR
            * `<条件1> OR <条件2>`
        + 通过添加`()`来实现复杂关系

    - 常用的条件表达式：`=` `>` `<` `>=` `<=` `<>` `LIKE`

* 投影查询
    - `SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM <表名> WHERE <条件表达式>`
    - 查询一个表满足条件的指定列结果，不返回全部表格内容
    - 可对返回的指定列进行重命名

* 排序 
    - 书写方式

        ```
        SELECT 列1 别名1, 列2 别名2, 列3 别名3
        FROM <表名>
        WHERE <条件表达式>
        ORDER BY 列1 (DESC),列2;
        ```
    
    - 将返回的结果按照某一条件进行升序/降序排列
    - 可对返回的指定列进行重命名
    - DESC表示倒序，ASC表示升序(默认方式，一般省略)
    - 当有相同值时，根据列2进行排序

* 分页查询 
    - `LIMIT <M> OFFSET <N>`
    - M 表示每页最多可以显示的结果数量
    - N 表示从第几页(索引)开始显示
    - 分页显示数据量过大的表格，但随索引的增大，查询速度变慢
    - OFFSET超过了查询的最大数量时可得到一个空的结果集
    - OFFSET默认从0开始，可省略
    - MySQL中，可以简写成`LIMIT M, N`

* 聚合查询 
    - `SELECT <调用聚合函数> 别名 FROM ...WHERE...GROUP BY...`
    - 使用聚合函数进行查询
    - 返回结果为二维表，一般需要指定新的列名
    - 常用聚合函数
        + COUNT() 计算个数，无匹配列返回0
        + AVG() 求均值，无匹配列返回NULL
        + SUM() 求和，无匹配列返回NULL
        + MIN() 最小值，可用于字符串，无匹配列返回NULL
        + MAX() 最大值，可用于字符串，无匹配列返回NULL
    - 分组
        + `GROUP BY 列名`
        + 先根据要求进行分组，在进行聚合计算

* 多表查询 
    - `SELECT 表别名1.列名1 列别名1,表别名2.列名 列别名2 FROM <表名1> <别名1>, <表名2> <别名2>`
    - 又称笛卡尔查询，查询多个表的乘积
    - 返回结果：列数为多个表的列数和，行数为多个表的行数积
    - 通过 表名.列名 设置新的列名
    - 可以使用WHERE

* 连接查询 
    - `SELECT ... FROM 主表 INNER JOIN 连接表 ON 连接条件 (WHERE...ORDER BY...)`
    - 多表查询的一种，先选定主表，在将其他表进行有选择性的连接
    - 连接方式：
        + 内连接 INNER JOIN 左右表都存在的记录
        + 外连接 OUTER JOIN 不存在的值补NULL
            * 左外连接 LEFT OUTER JOIN 左表存在的全部记录
            * 右外连接 RIGHT OUTER JOIN 右表存在的全部记录
            * 全外连接 FULL OUTER JOIN 左右表存在的全部记录

####  3. 修改语句  ####

* 插入
    - `INSERT INTO <表名> (字段1, 字段2, ...) VALUES (值1, 值2, ...),(值1, 值2, ...);`
    - 向数据库表插入一条新记录
    - 字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致
    - 若字段有默认值，那么在INSERT语句中可以省略
    - 可一次性添加多条记录

* 更新
    - `UPDATE <表名> SET 字段1=值1, 字段2=值2, ... WHERE ...;`
    - 一次更新表中满足目标条件的的一条或多条记录
    - 更新字段时可以使用表达式
    - 没有WHERE语句时，整个表的所有记录都会被更新
    - 最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新
    - 对于MySQL，使用UPDATE语句会返回更新的行数以及WHERE条件匹配的行数

* 删除
    - `DELETE FROM <表名> WHERE ...`
    - 一次删除表中满足目标条件的的一条或多条记录
    - 没有WHERE语句时，整个表的所有记录都会被删除
    - 与UPDATE语句相似，最好先用SELECT语句来测试，且使用MySQL时会返回行数

## 三. MySQL ##

####  1. 启动方式  ####

* 打开命令提示符，输入命令`mysql -u root -p`
* 输入口令，连接数据库，提示符变为`mysql>`
* 输入`exit`断开连接
* 连接远程数据库 `mysql -h <IP地址> -u root -p`

####  2. 基本语句  ####

* 列出所有数据库 `SHOW DATABASES`
* 创建新数据库 `CREATE DATABASE 数据库名`
* 删除数据库 `DROP DATABASE 数据库名`
* 切换为当前数据库 `USE 数据库名`
    - 列出当前数据库的所有表 `SHOW TABLES`
    - 查看表的结构 `DESC 表名`
    - 查看创建表的SQL语句 `SHOW CREATE TABLE 表名`
    - 创建表 `CREATE TABLE 表名`
    - 删除表 `DROP TABLE 表名`
    - 新增列 `ALTER TABLE 表名 ADD COLUMN 列名 数据类型 NOT NULL`
    - 修改列 `ALTER TABLE 表名 CHANGE COLUMN 原列名 新列名 新数据类型 NOT NULL`
    - 删除列 `ALTER TABLE 表名 DROP COLUMN 列名`
* 退出MySQL `EXIT`

####  3. 常用语句  ####

* 插入或替换
    - `REPLACE INTO 表名 (列名1, 列名2, ...) VALUES (value1, value2, ...)`
    - 先查询，如存在，则先删除原值再插入，若不存在则插入

* 插入或更新
    - `INSERT INTO 表名 (列名1, 列名2, ...) VALUES (value1, value2, ...) ON DUPLICATE KEY UPDATE 列名1=value1, 列名2=value2...`
    - 先查询，如存在，则不变，若不存在则更新

* 插入或忽略
    - `INSERT IGNORE INTO 表名 (列名1, 列名2, ...) VALUES (value1, value2, ...)`
    - 先查询，如存在，则不进行任何操作，若不存在则插入

* 快照
    - `CREATE TABLE 新表 SELECT * FROM 原表 WHERE ...`
    - 复制一份当前表的数据到一个新表

* 写入查询结果集
    - `INSERT INTO 结果集名 (列名1, 列名2) SELECT ... FROM ... GROUP BY ...`
    - 将满足条件的查询结果集写入到表

* 强制使用指定索引
    - `SELECT * FROM 表名 FORCE INDEX (索引名) WHERE ... ORDER BY ... DESC;`
    - 强制使用指定索引,索引值必须存在


## 四. 数据库事务 ##

#### 1. 基本概念 ####

* 定义：把多条语句作为一个整体进行操作的功能，以确保该事务范围内的所有操作全部成功或者全部失败，若失败对数据库不做任何改动
* 特性：ACID
    - A(Atomic)：原子性，将所有SQL作为原子工作单元执行
    - C(Consistent)：一致性，事务完成后，所有数据的状态都是一致的
    - I(Isolation)：隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离
    - D(Duration)：持久性，即事务完成后，对数据库数据的修改被持久化存储
* 分类
    - 隐式事务：单条SQL语句
    - 显式事务：多条SQL语句
        + 表达式
            ``` 
            BEGIN;
            语句1;
            语句2;
            ...
            COMMIT/ROLLBACK;
            ```
        + COMMIT：提交事务，若提交失败，则事务不生效
        + ROLLBACK：回滚事务，手动使事务失败

* 定义隔离级别
    - `SET TRANSACTION ISOLATION LEVEL 隔离级别关键字;`

#### 2. 隔离级别 ####

以下四种隔离级别按照由低到高的顺序:

* Read Uncommitted
    - 一个事务会读到另一个事务更新后但未提交的数据
    - 脏读(Dirty Read): 若另一个事务回滚，那么当前事务读到的数据就是脏数据
* Read Committed
    - 不可重复读(Non Repeatable Read)：事务不可重复读同一条记录，因为很可能读到的结果不一致
* Repeatable Read
    - 幻读(Phantom Read)：没有读到的记录默认为不存在，但实际可以成功更新，且更新成功后，可成功再次读取
* Serializable
    - 所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现
    - 由于逻辑串行执行，效率低，一般不用
